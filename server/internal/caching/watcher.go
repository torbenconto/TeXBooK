package caching

import (
	"crypto/sha1"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/fsnotify/fsnotify"
	"github.com/torbenconto/TeXBooK/internal/datasources"
	"github.com/torbenconto/TeXBooK/internal/logger"
)

var (
	WatchersMap = make(map[uint32]*Watcher)
	JobQueue    = make(chan CacheJob, 200)
	FsWatcher   *fsnotify.Watcher
)

func StartWatchingDataSource(ds datasources.DataSource) {
	local, ok := ds.(*datasources.LocalDataSource)
	if !ok {
		return
	}

	if FsWatcher == nil {
		var err error
		FsWatcher, err = fsnotify.NewWatcher()
		if err != nil {
			logger.Log.WithError(err).Error("Failed to create fsnotify watcher")
			return
		}
	}

	watcher := NewWatcher(FsWatcher, ds, JobQueue)
	WatchersMap[ds.ID()] = watcher

	go watcher.Start()
	go watcher.WarmUpExistingFiles()

	watcher.AddDirAndSubDirs(local.Path())
}

type CacheJob struct {
	Path       string
	DataSource string
}

type Watcher struct {
	watcher    *fsnotify.Watcher
	jobQueue   chan CacheJob
	dataSource datasources.DataSource
}

func NewWatcher(fsnotifyWatcher *fsnotify.Watcher, dataSource datasources.DataSource, queue chan CacheJob) *Watcher {
	return &Watcher{
		watcher:    fsnotifyWatcher,
		jobQueue:   queue,
		dataSource: dataSource,
	}
}

func (w *Watcher) AddDirAndSubDirs(root string) {
	filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			err := w.watcher.Add(path)
			if err != nil {
				logger.Log.WithError(err).WithField("path", path).Error("Failed to watch path")
			}
		}
		return nil
	})
}

func (w *Watcher) Start() {
	defer w.watcher.Close()

	for {
		select {
		case event, ok := <-w.watcher.Events:
			if !ok {
				return
			}

			if event.Op&(fsnotify.Create|fsnotify.Write) != 0 {
				info, err := os.Stat(event.Name)
				if err != nil {
					continue
				}

				if info.IsDir() && info.Name() != "cache" {
					err = w.watcher.Add(event.Name)
					if err != nil {
						logger.Log.WithError(err).WithField("name", event.Name).Error("Failed to add newly created dir to watcher")
						continue
					}
					logger.Log.WithField("name", event.Name).Info("Added subdir to watcher")
				} else if info.IsDir() {
					continue
				}

				if strings.HasSuffix(strings.ToLower(info.Name()), ".tex") {
					w.jobQueue <- CacheJob{
						Path: event.Name,
					}
				}
			}

			if event.Op&fsnotify.Remove != 0 {
				if strings.HasSuffix(strings.ToLower(event.Name), ".tex") {
					hash := sha1.Sum([]byte(event.Name))

					cachedPath := filepath.Join("cache", fmt.Sprintf("%x", hash))
					// Files generated by pdflatex with the same name
					extensions := []string{".pdf", ".aux", ".log"}

					for _, ext := range extensions {

						if err := os.Remove(filepath.Join(w.dataSource.Path(), cachedPath+ext)); err != nil && !os.IsNotExist(err) {
							logger.Log.WithError(err).WithField("file", cachedPath+ext).Error("Failed to delete cached file")
						}

						logger.Log.WithField("file", cachedPath+ext).Info("Deleted cached file")
					}

				}
			}
		case err, ok := <-w.watcher.Errors:
			if !ok {
				return
			}

			logger.Log.WithError(err).Error("Watcher error")
		}
	}
}

func (w *Watcher) WarmUpExistingFiles() {
	err := filepath.WalkDir(w.dataSource.(*datasources.LocalDataSource).Path(), func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(strings.ToLower(d.Name()), ".tex") {
			hash := sha1.Sum([]byte(path))

			cachedPath := filepath.Join("cache", fmt.Sprintf("%x", hash)+".pdf")
			if _, err := os.Stat(cachedPath); os.IsNotExist(err) {
				w.jobQueue <- CacheJob{Path: path}
			}
		}
		return nil
	})
	if err != nil {
		log.Printf("Warm-up failed for %d: %v", w.dataSource.ID(), err)
	}
}
